================================================================================
                        FLYING SWORD - ARCHITECTURE
================================================================================

SCENE HIERARCHY:
================================================================================

Main (Node) [game_manager.gd]
│
├── Background (ColorRect)
│
├── Player (Area2D) [player.gd]
│   ├── AnimatedSprite2D
│   ├── CollisionShape2D
│   └── AudioStreamPlayer2D (flap sound)
│
├── Floor (StaticBody2D) [floor.gd]
│   ├── Sprite2D
│   └── CollisionShape2D
│
├── Camera2D
│
├── SpawnTimer (Timer)
│
├── ScoreSound (AudioStreamPlayer2D)
│
├── DeathSound (AudioStreamPlayer2D)
│
├── StartScreen (CanvasLayer) [start_screen.gd]
│   └── UI elements...
│
├── GameOverScreen (CanvasLayer) [game_over_screen.gd]
│   └── UI elements...
│
├── HUD (CanvasLayer) [hud.gd]
│   └── ScoreLabel
│
└── [Mountains spawned dynamically] (Node2D) [mountain.gd]
    ├── TopMountain (Area2D)
    │   ├── Sprite2D
    │   └── CollisionShape2D
    ├── BottomMountain (Area2D)
    │   ├── Sprite2D
    │   └── CollisionShape2D
    └── ScoreZone (Area2D)
        └── CollisionShape2D


SIGNAL FLOW (Up the Tree):
================================================================================

    Player                      Game Manager
      │                              │
      ├── player_scored ────────────>│─── Increment score
      │                              │    Play sound
      │                              │    Update HUD
      │                              │
      └── player_died ──────────────>│─── Play sound
                                     │    Stop game
                                     │    Show game over


METHOD CALL FLOW (Down the Tree):
================================================================================

    Game Manager
         │
         ├──> Player.reset()
         │
         ├──> Floor.start_scrolling()
         ├──> Floor.stop_scrolling()
         ├──> Floor.reset()
         │
         ├──> HUD.update_score(score)
         ├──> HUD.show_hud() / hide_hud()
         │
         ├──> StartScreen.show_screen() / hide_screen()
         │
         └──> GameOverScreen.show_screen(score, high_score)


GAME STATE MACHINE:
================================================================================

    ┌─────────┐
    │  START  │ <──────────────┐
    └────┬────┘                │
         │ Click               │ Click
         │ start_game()        │ restart_game()
         v                     │
    ┌─────────┐                │
    │ PLAYING │                │
    └────┬────┘                │
         │ Collision           │
         │ stop_game()         │
         v                     │
    ┌───────────┐              │
    │ GAME_OVER │──────────────┘
    └───────────┘


COLLISION LAYERS:
================================================================================

Layer 1: Player
    - Detects: Layers 2 (Obstacles) and 3 (Score Zones)

Layer 2: Obstacles (Mountains, Floor)
    - Detected by: Layer 1 (Player)

Layer 3: Score Zones
    - Detected by: Layer 1 (Player)


MEMORY MANAGEMENT:
================================================================================

Mountains are dynamically spawned and must be cleaned up:

1. During Gameplay:
   Mountain._process() checks if off-screen
   └── If true: queue_free() removes itself

2. On Restart:
   GameManager.cleanup_mountains()
   └── Finds all Mountain nodes
       └── Calls queue_free() on each


FILE ORGANIZATION:
================================================================================

scenes/
├── main.tscn              - Root scene, contains everything
├── player/
│   └── player.tscn        - Reusable player component
├── mountain/
│   └── mountain.tscn      - Reusable mountain (instanced many times)
├── floor/
│   └── floor.tscn         - Scrolling floor
└── ui/
    ├── start_screen.tscn  - Start UI
    ├── game_over_screen.tscn - Game over UI
    └── hud.tscn           - In-game score display

scripts/
├── game_manager.gd        - Main game logic (state, spawning, scoring)
├── player.gd              - Player physics and input
├── mountain.gd            - Mountain scrolling and scoring
├── floor.gd               - Floor scrolling
├── start_screen.gd        - Start UI logic
├── game_over_screen.gd    - Game over UI logic
└── hud.gd                 - HUD logic

assets/
├── audio/                 - Sound effects
└── sprites/               - Visual assets


KEY DESIGN PATTERNS:
================================================================================

1. SEPARATION OF CONCERNS
   - Each script handles one responsibility
   - Player knows physics, not game state
   - Game Manager knows state, not physics

2. SIGNAL-DRIVEN COMMUNICATION
   - Children emit signals (events)
   - Parents listen and respond
   - Loose coupling between components

3. SCENE INSTANCING
   - Mountains are templates
   - Instantiate as needed
   - Each instance is independent

4. RESOURCE CLEANUP
   - queue_free() when no longer needed
   - Prevents memory leaks
   - Critical for spawned objects


IMPLEMENTATION TIP:
================================================================================

Start with one component at a time:
1. Get player falling and flapping
2. Get floor scrolling
3. Get mountains spawning
4. Add collisions
5. Add game states
6. Add scoring
7. Add persistence
8. Polish with audio and visuals

Test after each step!

================================================================================
